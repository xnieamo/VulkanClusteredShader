#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable


struct Light 
{
	vec4 pos;
	vec4 col;
	vec4 vel;
};

layout(binding = 0) uniform UniformBufferObject {
	int height;
    int width;
    int xtiles;
    int ytiles;
    int max_lights_per_cluster;
    int number_lights;
    int tile_size;
    mat4 model;
    mat4 view;
    mat4 proj;

} ubo;

layout(std430, binding = 1) buffer LightBuffer
{
	Light lights[];
} lightBuffer;

layout(std430, binding = 2) buffer IndexLookup
{
	int data[];
} indexLookupBuffer;


// Shared values between all the threads in the group
shared uint visibleLightCount;
vec4 frustumPlanes[4];
// Shared local storage for visible indices, will be written out to the global buffer at the end
shared int visibleLightIndices[100];
shared mat4 viewProjection;

#define LIGHT_NUM 100


void createFrustumPlanes() {
	// Left
	frustumPlanes[0].x = viewProjection[3][0] + viewProjection[0][0];
	frustumPlanes[0].y = viewProjection[3][1] + viewProjection[0][1];
	frustumPlanes[0].z = viewProjection[3][2] + viewProjection[0][2];
	frustumPlanes[0].w = viewProjection[3][3] + viewProjection[0][3];

	// Right
	frustumPlanes[1].x = viewProjection[3][0] - viewProjection[0][0];
	frustumPlanes[1].y = viewProjection[3][1] - viewProjection[0][1];
	frustumPlanes[1].z = viewProjection[3][2] - viewProjection[0][2];
	frustumPlanes[1].w = viewProjection[3][3] - viewProjection[0][3];

	// Top
	frustumPlanes[2].x = viewProjection[3][0] - viewProjection[1][0];
	frustumPlanes[2].y = viewProjection[3][1] - viewProjection[1][1];
	frustumPlanes[2].z = viewProjection[3][2] - viewProjection[1][2];
	frustumPlanes[2].w = viewProjection[3][3] - viewProjection[1][3];
	
	// Bottom
	frustumPlanes[3].x = viewProjection[3][0] + viewProjection[1][0];
	frustumPlanes[3].y = viewProjection[3][1] + viewProjection[1][1];
	frustumPlanes[3].z = viewProjection[3][2] + viewProjection[1][2];
	frustumPlanes[3].w = viewProjection[3][3] + viewProjection[1][3];

	// // Far
	// frustumPlanes[4].x = viewProjection[3][0] + viewProjection[2][0] * 100.0;
	// frustumPlanes[4].y = viewProjection[3][1] + viewProjection[2][1] * 100.0;
	// frustumPlanes[4].z = viewProjection[3][2] + viewProjection[2][2] * 100.0;
	// frustumPlanes[4].w = viewProjection[3][3] + viewProjection[2][3] * 100.0;

	// // Top
	// frustumPlanes[5].x = viewProjection[3][0] - viewProjection[2][0] * 0.1;
	// frustumPlanes[5].y = viewProjection[3][1] - viewProjection[2][1] * 0.1;
	// frustumPlanes[5].z = viewProjection[3][2] - viewProjection[2][2] * 0.1;
	// frustumPlanes[5].w = viewProjection[3][3] - viewProjection[2][3] * 0.1;

	for (int i = 0; i < 4; i++) {
		frustumPlanes[i] /= length(frustumPlanes[i].xyz);
	}
}

// Took some light culling guidance from Dice's deferred renderer
// http://www.dice.se/news/directx-11-rendering-battlefield-3/

#define TILE_SIZE 32
layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE) in;
void main() {



	ivec2 location = ivec2(gl_GlobalInvocationID.xy);
	ivec2 itemID = ivec2(gl_LocalInvocationID.xy);
	ivec2 tileID = ivec2(gl_WorkGroupID.xy);
	ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);
	uint index = tileID.y * tileNumber.x + tileID.x;

	// Initialize shared global values for depth and light count
	if (gl_LocalInvocationIndex == 0) {
		visibleLightCount = 0;
		viewProjection = ubo.proj * ubo.view;
	}

	int l_index = location.x;
	if (l_index < LIGHT_NUM) {
		// Update velocity
		vec4 pos = lightBuffer.lights[l_index].pos;
		vec4 vel = lightBuffer.lights[l_index].vel;
		// pos[1] += vel[0]*0.1;
		if (pos[1] >= vel[1])
			pos[1] = vel[2];

		lightBuffer.lights[l_index].pos = pos;
	}

	barrier();

	// // Calculate the frustum coordinates in screen space
	// if (gl_LocalInvocationIndex == 0) {
	// 	vec2 screenFrustum[4];

	// 	screenFrustum[0] = vec2( tileID * TILE_SIZE );
	//     screenFrustum[1] = vec2( tileID.x + 1, tileID.y );
	//     screenFrustum[2] = vec2( tileID.x, tileID.y + 1 );
	//     screenFrustum[3] = vec2( tileID.x + 1, tileID.y + 1 );

	//     // Convert to view space
	//     vec3 viewFrustum[4];
	//     for (int i = 0; i < 4; i++) {
	//     	vec2 tex = screenFrustum[i] / vec2(ubo.width, ubo.height);
	//     	viewFrustum[i] = vec3(vec2(tex.x, 1.0f - tex.y) * 2.0f - 1.0f, 1.0f);
	//     }

	//     // Compute planes
	//     vec3 eye = vec3(0.0, 0.0, 0.0);
	//     for (int i = 0; i < 4; i++) {
	//     	vec3 v0 = viewFrustum[i] - eye;
	// 		vec3 v1 = viewFrustum[(i + 1) % 4] - eye;

	// 		frustumPlanes[i].xyz = normalize(cross(v0, v1));
	// 		frustumPlanes[i].w = dot(frustumPlanes[i].xyz, eye);
	//     }
	// }

	if (gl_LocalInvocationIndex == 0) {
		vec2 tileScale = vec2(ubo.width, ubo.height) * (1.0f / float(2 * TILE_SIZE));
		vec2 tileBias  = tileScale - tileID;

		vec4 c1 = vec4(-ubo.proj[0][0] * tileScale.x, 0.0f, tileBias.x, 0.0f);
		vec4 c2 = vec4(0.0f, -ubo.proj[1][1] * tileScale.y, tileBias.y, 0.0f);
		vec4 c4 = vec4(0.0f, 0.0f, 1.0f, 0.0f);

		frustumPlanes[0] = c4 - c1;
		frustumPlanes[1] = c4 + c1;
		frustumPlanes[2] = c4 - c2;
		frustumPlanes[3] = c4 + c2;

		for(int i = 0; i < 4; i++)
		{
		    frustumPlanes[i] *= 1.0f / length(frustumPlanes[i].xyz);
		}

	}

	barrier();

	// Test lights against tiles
	// WORKS??

	uint lightCount = ubo.number_lights;
	uint threadCount = TILE_SIZE * TILE_SIZE;
	uint passCount = (lightCount + threadCount - 1) / threadCount;
	for (uint i = 0; i < passCount; i++) {
		// Get the lightIndex to test for this thread / pass. If the index is >= light count, then this thread can stop testing lights
		uint lightIndex = i * threadCount + (itemID.y * TILE_SIZE + itemID.x);
		if (lightIndex >= lightCount) {
			break;
		}

		vec4 position = lightBuffer.lights[lightIndex].pos;
		float radius = lightBuffer.lights[lightIndex].vel.w;

		position = ubo.proj * ubo.view * vec4(position.xyz, 1.0);
		// position /= position.w;

		// We check if the light exists in our frustum
		bool inFrustum = true;
		for (uint j = 0; j < 4; j++) {
			float dist = dot(frustumPlanes[i].xyz, position.xyz);
			inFrustum = inFrustum && (-radius <= dist);
		}

		// If greater than zero, then it is a visible light
		if (inFrustum) {
			// Add index to the shared array of visible indices
			uint offset = atomicAdd(visibleLightCount, 1);
			visibleLightIndices[offset] = int(lightIndex);
		}
	}

	// uint l_offset = atomicAdd(visibleLightCount, 1);
	// visibleLightIndices[l_offset] = int(l_offset);
	
	barrier();



	// // One thread should fill the global light buffer
	// if (itemID.x == 0 && itemID.y ==0) {
		// indexLookupBuffer.data[itemID.x] = itemID.x;
	uint offset = index * 50; // Determine bosition in global buffer
	for (uint i = 0; i < min(visibleLightCount, ubo.max_lights_per_cluster) ; i++) {
		indexLookupBuffer.data[i + offset] = visibleLightIndices[i];
	}

	if (visibleLightCount < ubo.max_lights_per_cluster) {
		indexLookupBuffer.data[visibleLightCount + offset] = -1;
	}

}