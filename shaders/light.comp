#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

#define MAX_INT 2147483647
#define MIN_INT -1 * 2147483647

struct Light 
{
	vec4 pos;
	vec4 col;
	vec4 vel;
};


layout(binding = 0) uniform UniformBufferObject {
	int height;
    int width;
    int xtiles;
    int ytiles;
    int max_lights_per_cluster;
    int number_lights;
    int tile_size;
    mat4 model;
    mat4 view;
    mat4 proj;

} ubo;

layout(std430, binding = 1) buffer LightsA
{
	Light lights[];
};

layout(std430, binding = 2) buffer Clusters
{
	uint lightIndexLookup[];
};

layout(std430, binding = 3) buffer ClustersData
{
	// ivec2 lookupIndices[];
	uint lookupIndices[][2];
};

layout(local_size_x = 16, local_size_y = 16) in;



const float Z_explicit[10] = {0.05, 0.23f, 0.52f, 1.2f, 2.7f, 6.0f, 14.f, 31.f, 71.f, 161.f};
int findZ (float z) {

    float minDiff = 1000000.f;
    int minIdx = -1;
    for (int i = 0; i < 10; i++) {
    	float tempDiff = z - Z_explicit[i];
    	if (tempDiff < minDiff && tempDiff >= 0.f) {
    		minDiff = tempDiff;
    		minIdx = i;
    	}
    }
	return minIdx;
}

bool inBound(int minVal, int maxVal, int minBound, int maxBound) {
	return (minVal >= minBound && minVal <= maxBound && maxVal >= maxBound && maxVal <= maxBound);
}

shared uint counter;
shared uint maxIndex;

void assignLight(Light l, int index) {
	int X = ubo.xtiles;
	int Y = ubo.ytiles;
	int Z = 10;

	// Get position and attenuation distance 
	vec4 pos = l.pos;
	float attDist = l.vel[3]*2;

	// Set w to 1
	pos[3] = 1.0;

	// Find corners of AABB
	vec4[8] aabb = {
		vec4(pos + vec4(attDist, attDist, attDist, 0.f)),
		vec4(pos + vec4(attDist, attDist, -attDist, 0.f)),
		vec4(pos + vec4(attDist, -attDist, attDist, 0.f)),
		vec4(pos + vec4(attDist, -attDist, -attDist, 0.f)),
		vec4(pos + vec4(-attDist, attDist, attDist, 0.f)),
		vec4(pos + vec4(-attDist, attDist, -attDist, 0.f)),
		vec4(pos + vec4(-attDist, -attDist, attDist, 0.f)),
		vec4(pos + vec4(-attDist, -attDist, -attDist, 0.f))
	};

	// Find max/min bounds in screen space
	ivec3 min_screen = ivec3(MAX_INT);
	ivec3 max_screen = ivec3(MIN_INT);
	for (int i = 0; i < 8; i++) {
		vec4 pos = aabb[i];

		// Project into view space
		pos = ubo.proj * ubo.view * ubo.model * pos;
		float z = pos[2];
		pos = pos / pos.w;

		// Calculate screen space coords for X and Y
		int Sx = clamp(int(round((pos.x + 1) / 2.f * ubo.width)) / ubo.tile_size, -1, X + 1);
		int Sy = clamp(int(round((1 - pos.y) / 2.f * ubo.height)) / ubo.tile_size, -1, Y + 1);

		// Update min and max
		if (Sx < min_screen[0]) { min_screen[0] = Sx; }
		if (Sx > max_screen[0]) { max_screen[0] = Sx; }
		if (Sy < min_screen[1]) { min_screen[1] = Sy; }
		if (Sy > max_screen[1]) { max_screen[1] = Sy; }

		// Find Z plane and update min/max
		int Sz = findZ(z);
		if (Sz < min_screen[2]) { min_screen[2] = Sz; }
		if (Sz > max_screen[2]) { max_screen[2] = Sz; }
	}

	// Clamp final min/max values if part of or the entire AABB
	// intersects with the clusters
	if (!(min_screen[0] < 0 && max_screen[0] < 0) && !(min_screen[0] > X && max_screen[0] > X)) {
		min_screen[0] = clamp(min_screen[0], 0, X);
		max_screen[0] = clamp(max_screen[0], 0, X);
	}

	if (!(min_screen[1] < 0 && max_screen[1] < 0) && !(min_screen[1] > Y && max_screen[1] > Y)) {
		min_screen[1] = clamp(min_screen[1], 0, Y);
		max_screen[1] = clamp(max_screen[1], 0, Y);
	}

	if (!(min_screen[2] < 0 && max_screen[2] < 0) && !(min_screen[2] > Z && max_screen[2] > Z)) {
		min_screen[2] = clamp(min_screen[2]-1, 0, Z);
		max_screen[2] = clamp(max_screen[2]+1, 0, Z);
	}

	// Loop over indices and add light to buffer
	if (inBound(min_screen[0], max_screen[0], 0, X) && inBound(min_screen[1], max_screen[1], 0, Y)) {
		for (int i = min_screen[0]; i <= max_screen[0]; i++) {
			for (int j = min_screen[1]; j <= max_screen[1]; j++) {
				for (int k = min_screen[2]; k <= max_screen[2]; k++) {
				
					if (i >= 0 && j >= 0 && k >= 0) {
						int clusterIdx = i + j * (X+1) + k * (Y+1) * (X+1);
						uint dataIdx = atomicAdd(lookupIndices[clusterIdx][1], 1);
						if (dataIdx < ubo.max_lights_per_cluster)
							lightIndexLookup[dataIdx] = index;
					}
				}
			}
		}
	}

}

void main()
{
	counter = 0;
	maxIndex = 0;
	// Current SSBO index
	uint index = gl_GlobalInvocationID.x;
	// Don't try to write beyond particle count
	if (index >= ubo.number_lights)
		return;

	// Update velocity
	vec4 pos = lights[index].pos;
	vec4 vel = lights[index].vel;
	pos[1] += vel[0];
	if (pos[1] >= vel[1])
		pos[1] = vel[2];

	lights[index].pos = pos;

	// uint test = lightIndexLookup[0];
	// uint test2 = lookupIndices[0][0];

	// // Allocate light to clusters
	
	// // Find cluster index
	// // Bind light in AABB
	// float attDist = vel[3];
	// pos[3] = 1.f;
	// vec4 posMax = pos + vec4(vec3(attDist), 0.f);
	// vec4 posMin = pos - vec4(vec3(attDist), 0.f);

	// // 1. Convert AABB to view space
	// vec4 viewMax = ubo.proj * ubo.view * ubo.model * posMax;
	// vec4 viewMin = ubo.proj * ubo.view * ubo.model * posMin;

	// viewMax = viewMax / viewMax.w;
	// viewMin = viewMin / viewMin.w;

	// // 2a. Find max number of tiles
	// int X = ubo.width / ubo.tile_size;
	// int Y = ubo.height / ubo.tile_size;

	// // 2. Convert to screen space 
	// // Max coordinates
	// int Sx_p = clamp(int(round((viewMax.x + 1) / 2.f * ubo.width)) / ubo.tile_size, -1, X + 1);
	// int Sy_p = clamp(int(round((1 - viewMax.y) / 2.f * ubo.height))/ ubo.tile_size, -1, Y + 1);
	// int Sz_p = viewMax.w > 0.f ? findZ(viewMax.z) : -1;

	// // Min coordinates
	// int Sx_m = clamp(int(round((viewMin.x + 1) / 2.f * ubo.width)) / ubo.tile_size, -1, X + 1);
	// int Sy_m = clamp(int(round((1 - viewMin.y) / 2.f * ubo.height))/ ubo.tile_size, -1, Y + 1);
	// int Sz_m = viewMin.w > 0.f ? findZ(viewMin.z) : -1;

	// // 

	// // Swap max and min if they do not hold actual values
	// if (Sx_m > Sx_p) {
	// 	int temp = Sx_m;
	// 	Sx_m = Sx_p;
	// 	Sx_p = temp;
	// }

	// if (Sy_m > Sy_p) {
	// 	int temp = Sy_m;
	// 	Sy_m = Sy_p;
	// 	Sy_p = temp;
	// }

	// if (Sz_m > Sz_p) {
	// 	int temp = Sz_m;
	// 	Sz_m = Sz_p;
	// 	Sz_p = temp;
	// }

	// // Update clamping condition if min > minBound || max < maxBound
	// if (Sx_m >= 0 || Sx_p <= X) {
	// 	Sx_m = clamp(Sx_m, 0, X);
	// 	Sx_p = clamp(Sx_p, 0, X);
	// }

	// if (Sy_m >= 0 || Sy_p <= Y) {
	// 	Sy_m = clamp(Sy_m, 0, Y);
	// 	Sy_p = clamp(Sy_p, 0, Y);
	// }

	// if (Sz_m >= 0 || Sz_p <= Y) {
	// 	Sz_m = clamp(Sz_m, 0, Y);
	// 	Sz_p = clamp(Sz_p, 0, Y);
	// }

	// // Need to initialize EVERYTHING TO 0 ... IDK WHY
	// int totalNum = ubo.ytiles * ubo.ytiles * 10;
	// uint start = min((totalNum / 96 + 1) * index, totalNum);
	// uint end   = min((totalNum / 96 + 1) * (index + 1), totalNum);
	// for (uint i = start; i < end; i++) {
	// 	lookupIndices[i][0] = 0;
	// 	lookupIndices[i][1] = 0;
	// }

	// barrier();

	// // lookupIndices[index][1] = inBound(Sy_m, Sy_p, 0, Y) ? uint(Sy_p - Sy_m) : 0;
	// // lookupIndices[index][0] = inBound(Sx_m, Sx_p, 0, X) ? uint(Sx_p - Sx_m) : 0;
	// // lookupIndices[index][0] = Sx_m;
	// // lookupIndices[index][1] = Sx_p;
	// // lookupIndices[index][2] = Sy_m;
	// // lookupIndices[index][3] = Sy_p;
	// // lookupIndices[index][4] = Sz_m;

	// // lookupIndices[index][0] = 0;
	// // lookupIndices[index][5] = 0;
	// // lookupIndices[index][4] = 0;




	// // if (inBound(Sx_m, Sx_p, 0, X) && inBound(Sy_m, Sy_p, 0, Y))
	// // 	lookupIndices[index][5] = (Sx_p - Sx_m + 1) * (Sy_p - Sy_m + 1) * (Sz_p - Sz_m + 1);

	// // 3. Fill index buffer by traversing AABB only if everything is inbounds though
	// if (inBound(Sx_m, Sx_p, 0, X) && inBound(Sy_m, Sy_p, 0, Y)) {
	// 	for (int i = Sx_m; i <= Sx_p; i++) {
	// 		for (int j = Sy_m; j <= Sy_m; j++) {
	// 			for (int k = Sz_m; k <= Sz_p; k++) {
	// 				// Unroll 3D index
	// 				uint clusterIdx = i + j * ubo.ytiles + k * ubo.ytiles * ubo.xtiles;

	// 				// Increment counter and save max counter
	// 				atomicAdd(lookupIndices[clusterIdx][0], 1);
	// 				lookupIndices[index][1] =  lookupIndices[clusterIdx][0];

	// 				// // Find where in the buffer this location is
	// 				// uint trueLookupIndex = clusterIdx * (ubo.max_lights_per_cluster) + l_index;

	// 				// // Assign light to appropriate counter and save where we stop
	// 				// lightIndexLookup[index]++;
	// 				// // atomicMax(lookupIndices[clusterIdx][1], l_index);
	// 				// lookupIndices[index][1]++;
	// 			}
	// 		}
	// 	}
	// }

	
}
